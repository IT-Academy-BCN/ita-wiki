/**
 * Generated by @openapi-codegen
 *
 * @version 0.18.3
 */
import * as reactQuery from "@tanstack/react-query";
import { useOpenapiContext, OpenapiContext } from "./openapiContext";
import type * as Fetcher from "./openapiFetcher";
import { openapiFetch } from "./openapiFetcher";
import type * as Schemas from "./openapiSchemas";

export type PostLoginError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationError;
    }
  | {
      status: 401;
      payload: Schemas.MissingUserError;
    }
  | {
      status: 403;
      payload: Schemas.ForbiddenError;
    }
  | {
      status: 404;
      payload: Schemas.MissingUserError;
    }
  | {
      status: 422;
      payload: {
        /**
         * @example Invalid password
         */
        message: string;
      };
    }
  | {
      status: 503;
      payload: Schemas.ServiceUnavailableError & void;
    }
>;

export type PostLoginRequestBody = {
  dni: string;
  /**
   * @minLength 8
   */
  password: string;
};

export type PostLoginVariables = {
  body: PostLoginRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Takes a DNI and a password and returns a session cookie
 */
export const fetchPostLogin = (
  variables: PostLoginVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<undefined, PostLoginError, PostLoginRequestBody, {}, {}, {}>({
    url: "/api/v1/auth/login",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Takes a DNI and a password and returns a session cookie
 */
export const usePostLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostLoginError,
      PostLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<undefined, PostLoginError, PostLoginVariables>({
    mutationFn: (variables: PostLoginVariables) =>
      fetchPostLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostRegisterError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationError | Schemas.DniError | Schemas.EmailError;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
>;

export type PostRegisterRequestBody = {
  /**
   * @format email
   * @example user@example.cat
   */
  email: string;
  dni: string;
  /**
   * @minLength 1
   */
  itineraryId: string;
  name: string;
  accept: true;
  /**
   * @minLength 8
   * @pattern ^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]*$
   */
  password: string;
  /**
   * @minLength 8
   * @pattern ^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]*$
   */
  confirmPassword: string;
};

export type PostRegisterVariables = {
  body: PostRegisterRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Takes a DNI, a password, a name and an email an registers a user to the system
 */
export const fetchPostRegister = (
  variables: PostRegisterVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PostRegisterError,
    PostRegisterRequestBody,
    {},
    {},
    {}
  >({ url: "/api/v1/auth/register", method: "post", ...variables, signal });

/**
 * Takes a DNI, a password, a name and an email an registers a user to the system
 */
export const usePostRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostRegisterError,
      PostRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PostRegisterError,
    PostRegisterVariables
  >({
    mutationFn: (variables: PostRegisterVariables) =>
      fetchPostRegister({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetMeError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 404;
      payload: Schemas.MissingUserError;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
>;

export type GetMeResponse = {
  id: string;
  name?: string;
  dni: string;
  /**
   * @format email
   * @example user@example.cat
   */
  email: string;
  role: "ADMIN" | "MENTOR" | "REGISTERED";
  status: "ACTIVE" | "INACTIVE";
};

export type GetMeVariables = OpenapiContext["fetcherOptions"];

/**
 * Returns information of a logged in user. Token recieved in the login necessary.
 */
export const fetchGetMe = (variables: GetMeVariables, signal?: AbortSignal) =>
  openapiFetch<GetMeResponse, GetMeError, undefined, {}, {}, {}>({
    url: "/api/v1/auth/me",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Returns information of a logged in user. Token recieved in the login necessary.
 */
export const useGetMe = <TData = GetMeResponse,>(
  variables: GetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetMeResponse, GetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<GetMeResponse, GetMeError, TData>({
    queryKey: queryKeyFn({
      path: "/api/v1/auth/me",
      operationId: "getMe",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetLogoutError = Fetcher.ErrorWrapper<undefined>;

export type GetLogoutVariables = OpenapiContext["fetcherOptions"];

/**
 * Deletes cookie and logouts user
 */
export const fetchGetLogout = (
  variables: GetLogoutVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<undefined, GetLogoutError, undefined, {}, {}, {}>({
    url: "/api/v1/auth/logout",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Deletes cookie and logouts user
 */
export const useGetLogout = <TData = undefined,>(
  variables: GetLogoutVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetLogoutError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<undefined, GetLogoutError, TData>({
    queryKey: queryKeyFn({
      path: "/api/v1/auth/logout",
      operationId: "getLogout",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetLogout({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ListCategoriesError = Fetcher.ErrorWrapper<undefined>;

export type ListCategoriesResponse = {
  id: string;
  /**
   * @example Javascript
   */
  name: string;
  /**
   * @example javascript
   */
  slug: string;
}[];

export type ListCategoriesVariables = OpenapiContext["fetcherOptions"];

/**
 * Get all categories saved in the database
 */
export const fetchListCategories = (
  variables: ListCategoriesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListCategoriesResponse,
    ListCategoriesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/categories", method: "get", ...variables, signal });

/**
 * Get all categories saved in the database
 */
export const useListCategories = <TData = ListCategoriesResponse,>(
  variables: ListCategoriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListCategoriesResponse,
      ListCategoriesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<
    ListCategoriesResponse,
    ListCategoriesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/api/v1/categories",
      operationId: "listCategories",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListCategories({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostCategoriesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 403;
      payload: Schemas.ForbiddenError & void;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
>;

export type PostCategoriesRequestBody = {
  /**
   * @example React
   */
  name: string;
};

export type PostCategoriesVariables = {
  body: PostCategoriesRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Creates a new category. The requestor has to be logged in and with role ADMIN.
 */
export const fetchPostCategories = (
  variables: PostCategoriesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PostCategoriesError,
    PostCategoriesRequestBody,
    {},
    {},
    {}
  >({ url: "/api/v1/categories", method: "post", ...variables, signal });

/**
 * Creates a new category. The requestor has to be logged in and with role ADMIN.
 */
export const usePostCategories = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCategoriesError,
      PostCategoriesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PostCategoriesError,
    PostCategoriesVariables
  >({
    mutationFn: (variables: PostCategoriesVariables) =>
      fetchPostCategories({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchCategoriesPathParams = {
  /**
   * ID of the category to modify
   */
  categoryId: string;
};

export type PatchCategoriesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 403;
      payload: Schemas.ForbiddenError & void;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
>;

export type PatchCategoriesRequestBody = {
  /**
   * @example React
   */
  name: string;
};

export type PatchCategoriesVariables = {
  body: PatchCategoriesRequestBody;
  pathParams: PatchCategoriesPathParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Modifies an existing category. The requestor has to be logged in and with role ADMIN.
 */
export const fetchPatchCategories = (
  variables: PatchCategoriesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PatchCategoriesError,
    PatchCategoriesRequestBody,
    {},
    {},
    PatchCategoriesPathParams
  >({
    url: "/api/v1/categories/id/{id}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Modifies an existing category. The requestor has to be logged in and with role ADMIN.
 */
export const usePatchCategories = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCategoriesError,
      PatchCategoriesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PatchCategoriesError,
    PatchCategoriesVariables
  >({
    mutationFn: (variables: PatchCategoriesVariables) =>
      fetchPatchCategories({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ListTopicsQueryParams = {
  categoryId?: string;
  /**
   * @example javascript
   */
  slug?: string;
};

export type ListTopicsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.MissingUserError & void;
}>;

export type ListTopicsResponse = {
  id: string;
  /**
   * @example React Props
   */
  name: string;
  /**
   * @example react-props
   */
  slug?: string;
  categoryId: string;
}[];

export type ListTopicsVariables = {
  queryParams?: ListTopicsQueryParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Returns a list of all topics. Filter by category id or category slug possible. If both filters are sent, will only search by category id.
 */
export const fetchListTopics = (
  variables: ListTopicsVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListTopicsResponse,
    ListTopicsError,
    undefined,
    {},
    ListTopicsQueryParams,
    {}
  >({ url: "/api/v1/topics", method: "get", ...variables, signal });

/**
 * Returns a list of all topics. Filter by category id or category slug possible. If both filters are sent, will only search by category id.
 */
export const useListTopics = <TData = ListTopicsResponse,>(
  variables: ListTopicsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ListTopicsResponse, ListTopicsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<ListTopicsResponse, ListTopicsError, TData>({
    queryKey: queryKeyFn({
      path: "/api/v1/topics",
      operationId: "listTopics",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListTopics({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostTopicsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 403;
      payload: Schemas.ForbiddenError & void;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
>;

export type PostTopicsRequestBody = {
  /**
   * @example React Props
   */
  name: string;
  categoryId: string;
};

export type PostTopicsVariables = {
  body: PostTopicsRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Creates a new topic. The requestor has to be logged in and with role MENTOR or higher.
 */
export const fetchPostTopics = (
  variables: PostTopicsVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<undefined, PostTopicsError, PostTopicsRequestBody, {}, {}, {}>({
    url: "/api/v1/topics",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Creates a new topic. The requestor has to be logged in and with role MENTOR or higher.
 */
export const usePostTopics = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostTopicsError,
      PostTopicsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PostTopicsError,
    PostTopicsVariables
  >({
    mutationFn: (variables: PostTopicsVariables) =>
      fetchPostTopics({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchTopicsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 403;
      payload: Schemas.ForbiddenError & void;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
>;

export type PatchTopicsRequestBody = {
  id: string;
  /**
   * @example Advanced React Props
   */
  name?: string;
  categoryId?: string;
};

export type PatchTopicsVariables = {
  body: PatchTopicsRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Modifies an existing topic. The requestor has to be logged in and with role MENTOR or higher.
 */
export const fetchPatchTopics = (
  variables: PatchTopicsVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<undefined, PatchTopicsError, PatchTopicsRequestBody, {}, {}, {}>(
    { url: "/api/v1/topics", method: "patch", ...variables, signal },
  );

/**
 * Modifies an existing topic. The requestor has to be logged in and with role MENTOR or higher.
 */
export const usePatchTopics = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTopicsError,
      PatchTopicsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PatchTopicsError,
    PatchTopicsVariables
  >({
    mutationFn: (variables: PatchTopicsVariables) =>
      fetchPatchTopics({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ListFavoritesResourcesPathParams = {
  /**
   * @minLength 1
   */
  categorySlug: string;
};

export type ListFavoritesResourcesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 404;
      payload: Schemas.MissingUserError;
    }
>;

export type ListFavoritesResourcesResponse = {
  id: string;
  /**
   * @example My Resource in Javascript
   */
  title: string;
  /**
   * @example my-resource-in-javascript
   */
  slug: string;
  /**
   * @example Lorem ipsum javascript
   */
  description?: string | null;
  /**
   * @format uri
   * @example https://tutorials.cat/learn/javascript
   */
  url: string;
  resourceType: "BLOG" | "VIDEO" | "TUTORIAL";
  /**
   * @example clocr0bi20000h8vwipfbazso
   */
  categoryId: string;
  createdAt: string | string;
  updatedAt: string | string;
  user: {
    id: string;
    name?: string;
  };
  isAuthor: boolean;
  voteCount: {
    /**
     * @minimum 0
     * @example 14
     */
    upvote: number;
    /**
     * @minimum 0
     * @example 2
     */
    downvote: number;
    /**
     * @example 12
     */
    total: number;
    /**
     * @minimum -1
     * @maximum 1
     */
    userVote: number;
  };
  topics: {
    topic: {
      id: string;
      /**
       * @example React Props
       */
      name: string;
      /**
       * @example react-props
       */
      slug?: string;
      categoryId: string;
      createdAt: string | string;
      updatedAt: string | string;
    };
  }[];
}[];

export type ListFavoritesResourcesVariables = {
  pathParams: ListFavoritesResourcesPathParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Retrieves the users favorite resources when logged in
 */
export const fetchListFavoritesResources = (
  variables: ListFavoritesResourcesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListFavoritesResourcesResponse,
    ListFavoritesResourcesError,
    undefined,
    {},
    {},
    ListFavoritesResourcesPathParams
  >({
    url: "/api/v1/resources/favorites/{categorySlug}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieves the users favorite resources when logged in
 */
export const useListFavoritesResources = <
  TData = ListFavoritesResourcesResponse,
>(
  variables: ListFavoritesResourcesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListFavoritesResourcesResponse,
      ListFavoritesResourcesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<
    ListFavoritesResourcesResponse,
    ListFavoritesResourcesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/api/v1/resources/favorites/{categorySlug}",
      operationId: "listFavoritesResources",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListFavoritesResources({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ListResourcesQueryParams = {
  /**
   * Slug of the category for which to retrieve resources
   *
   * @example react
   */
  categorySlug?: string;
  /**
   * Slug of the topic for which to retrieve resources
   *
   * @example jsx
   */
  topicSlug?: string;
  /**
   * Resource types to filter by
   *
   * @uniqueItems true
   */
  resourceTypes?: ("BLOG" | "VIDEO" | "TUTORIAL")[];
  /**
   * ID string of the topic for which to retrieve resources. If not provided, resources for ALL topics are fetched.
   *
   * @example cln2u09xo0037s6wvbf6t9jfg
   */
  topic?: string;
  /**
   * Status to filter by
   *
   * @uniqueItems true
   */
  status?: ("SEEN" | "NOT_SEEN")[];
  /**
   * Search query to filter by
   */
  search?: string;
};

export type ListResourcesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationError;
    }
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
>;

export type ListResourcesResponse = {
  id: string;
  /**
   * @example My Resource in Javascript
   */
  title: string;
  /**
   * @example my-resource-in-javascript
   */
  slug: string;
  /**
   * @example Lorem ipsum javascript
   */
  description?: string | null;
  /**
   * @format uri
   * @example https://tutorials.cat/learn/javascript
   */
  url: string;
  resourceType: "BLOG" | "VIDEO" | "TUTORIAL";
  /**
   * @example clocr0bi20000h8vwipfbazso
   */
  categoryId: string;
  createdAt: string | string;
  updatedAt: string | string;
  user: {
    name?: string;
    id: string;
  };
  topics: {
    topic: {
      id: string;
      /**
       * @example React Props
       */
      name: string;
      /**
       * @example react-props
       */
      slug?: string;
      categoryId: string;
      createdAt: string | string;
      updatedAt: string | string;
    };
  }[];
  voteCount: {
    /**
     * @minimum 0
     * @example 14
     */
    upvote: number;
    /**
     * @minimum 0
     * @example 2
     */
    downvote: number;
    /**
     * @example 12
     */
    total: number;
    /**
     * @minimum -1
     * @maximum 1
     */
    userVote: number;
  };
  /**
   * @default false
   */
  isFavorite: boolean;
}[];

export type ListResourcesVariables = {
  queryParams?: ListResourcesQueryParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Returns a collection of resources. Filters by resource type, topic name and category slug are optional. Resources that match all filters are fetched.
 */
export const fetchListResources = (
  variables: ListResourcesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListResourcesResponse,
    ListResourcesError,
    undefined,
    {},
    ListResourcesQueryParams,
    {}
  >({ url: "/api/v1/resources", method: "get", ...variables, signal });

/**
 * Returns a collection of resources. Filters by resource type, topic name and category slug are optional. Resources that match all filters are fetched.
 */
export const useListResources = <TData = ListResourcesResponse,>(
  variables: ListResourcesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListResourcesResponse,
      ListResourcesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<ListResourcesResponse, ListResourcesError, TData>({
    queryKey: queryKeyFn({
      path: "/api/v1/resources",
      operationId: "listResources",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListResources({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PostResourcesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
}>;

export type PostResourcesRequestBody = {
  /**
   * @example My Resource in Javascript
   */
  title: string;
  /**
   * @example Lorem ipsum javascript
   */
  description?: string | null;
  /**
   * @format uri
   * @example https://tutorials.cat/learn/javascript
   */
  url: string;
  resourceType: "BLOG" | "VIDEO" | "TUTORIAL";
  /**
   * @example clocr0bi20000h8vwipfbazso
   */
  categoryId: string;
  topics: string[];
};

export type PostResourcesVariables = {
  body: PostResourcesRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Allows a logged in user to post a resource.
 */
export const fetchPostResources = (
  variables: PostResourcesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PostResourcesError,
    PostResourcesRequestBody,
    {},
    {},
    {}
  >({ url: "/api/v1/resources", method: "post", ...variables, signal });

/**
 * Allows a logged in user to post a resource.
 */
export const usePostResources = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostResourcesError,
      PostResourcesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PostResourcesError,
    PostResourcesVariables
  >({
    mutationFn: (variables: PostResourcesVariables) =>
      fetchPostResources({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PatchResourcesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
}>;

export type PatchResourcesRequestBody = {
  id: string;
  title?: string;
  description?: string;
  url?: string;
  topicId?: string;
  resourceType?: "BLOG" | "VIDEO" | "TUTORIAL";
};

export type PatchResourcesVariables = {
  body: PatchResourcesRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Allows a logged in user to modify his resources.
 */
export const fetchPatchResources = (
  variables: PatchResourcesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PatchResourcesError,
    PatchResourcesRequestBody,
    {},
    {},
    {}
  >({ url: "/api/v1/resources", method: "patch", ...variables, signal });

/**
 * Allows a logged in user to modify his resources.
 */
export const usePatchResources = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchResourcesError,
      PatchResourcesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PatchResourcesError,
    PatchResourcesVariables
  >({
    mutationFn: (variables: PatchResourcesVariables) =>
      fetchPatchResources({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PostUserSeenResourcesByIdPathParams = {
  /**
   * ID of the resource to be retrieved.
   *
   * @minLength 1
   * @example cln2u09xo0037s6wvbf6t9jfg
   */
  resourceId: string;
};

export type PostUserSeenResourcesByIdError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
}>;

export type PostUserSeenResourcesByIdVariables = {
  pathParams: PostUserSeenResourcesByIdPathParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Allows a logged in user to mark a resource as viewed.
 */
export const fetchPostUserSeenResourcesById = (
  variables: PostUserSeenResourcesByIdVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PostUserSeenResourcesByIdError,
    undefined,
    {},
    {},
    PostUserSeenResourcesByIdPathParams
  >({ url: "/api/v1/seen/{resourceId}", method: "post", ...variables, signal });

/**
 * Allows a logged in user to mark a resource as viewed.
 */
export const usePostUserSeenResourcesById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostUserSeenResourcesByIdError,
      PostUserSeenResourcesByIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PostUserSeenResourcesByIdError,
    PostUserSeenResourcesByIdVariables
  >({
    mutationFn: (variables: PostUserSeenResourcesByIdVariables) =>
      fetchPostUserSeenResourcesById({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetResourcesByIdPathParams = {
  /**
   * ID of the resource to be retrieved.
   *
   * @minLength 1
   * @example cln2u09xo0037s6wvbf6t9jfg
   */
  resourceId: string;
};

export type GetResourcesByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationError & void;
    }
  | {
      status: 404;
      payload: Schemas.MissingUserError & void;
    }
>;

export type GetResourcesByIdResponse = {
  id: string;
  /**
   * @example My Resource in Javascript
   */
  title: string;
  /**
   * @example my-resource-in-javascript
   */
  slug: string;
  /**
   * @example Lorem ipsum javascript
   */
  description?: string | null;
  /**
   * @format uri
   * @example https://tutorials.cat/learn/javascript
   */
  url: string;
  resourceType: "BLOG" | "VIDEO" | "TUTORIAL";
  /**
   * @example clocr0bi20000h8vwipfbazso
   */
  categoryId: string;
  createdAt: string | string;
  updatedAt: string | string;
  user: {
    name?: string;
    id: string;
  };
  topics: {
    topic: {
      id: string;
      /**
       * @example React Props
       */
      name: string;
      /**
       * @example react-props
       */
      slug?: string;
      categoryId: string;
      createdAt: string | string;
      updatedAt: string | string;
    };
  }[];
  voteCount: {
    /**
     * @minimum 0
     * @example 14
     */
    upvote: number;
    /**
     * @minimum 0
     * @example 2
     */
    downvote: number;
    /**
     * @example 12
     */
    total: number;
    /**
     * @minimum -1
     * @maximum 1
     */
    userVote: number;
  };
  /**
   * @default false
   */
  isFavorite: boolean;
};

export type GetResourcesByIdVariables = {
  pathParams: GetResourcesByIdPathParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Takes in a valid resource ID and returns the resource related to it.
 */
export const fetchGetResourcesById = (
  variables: GetResourcesByIdVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    GetResourcesByIdResponse,
    GetResourcesByIdError,
    undefined,
    {},
    {},
    GetResourcesByIdPathParams
  >({
    url: "/api/v1/resources/{resourceId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Takes in a valid resource ID and returns the resource related to it.
 */
export const useGetResourcesById = <TData = GetResourcesByIdResponse,>(
  variables: GetResourcesByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetResourcesByIdResponse,
      GetResourcesByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<
    GetResourcesByIdResponse,
    GetResourcesByIdError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/api/v1/resources/{resourceId}",
      operationId: "getResourcesById",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetResourcesById({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ListUserMeResourcesQueryParams = {
  /**
   * @example react
   */
  categorySlug?: string;
};

export type ListUserMeResourcesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 404;
      payload: Schemas.MissingUserError;
    }
>;

export type ListUserMeResourcesResponse = {
  resources: {
    id: string;
    /**
     * @example My Resource in Javascript
     */
    title: string;
    /**
     * @example my-resource-in-javascript
     */
    slug: string;
    /**
     * @example Lorem ipsum javascript
     */
    description?: string | null;
    /**
     * @format uri
     * @example https://tutorials.cat/learn/javascript
     */
    url: string;
    resourceType: "BLOG" | "VIDEO" | "TUTORIAL";
    /**
     * @example clocr0bi20000h8vwipfbazso
     */
    categoryId: string;
    createdAt: string | string;
    updatedAt: string | string;
    user: {
      name?: string;
      id: string;
    };
    topics: {
      topic: {
        id: string;
        /**
         * @example React Props
         */
        name: string;
        /**
         * @example react-props
         */
        slug?: string;
        categoryId: string;
        createdAt: string | string;
        updatedAt: string | string;
      };
    }[];
    voteCount: {
      /**
       * @minimum 0
       * @example 14
       */
      upvote: number;
      /**
       * @minimum 0
       * @example 2
       */
      downvote: number;
      /**
       * @example 12
       */
      total: number;
      /**
       * @minimum -1
       * @maximum 1
       */
      userVote: number;
    };
    /**
     * @default false
     */
    isFavorite: boolean;
  }[];
};

export type ListUserMeResourcesVariables = {
  queryParams?: ListUserMeResourcesQueryParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Returns all the posted resources by a logged in user. In addition, if categorySlug query provided, returns only the resources posted in that category.
 */
export const fetchListUserMeResources = (
  variables: ListUserMeResourcesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListUserMeResourcesResponse,
    ListUserMeResourcesError,
    undefined,
    {},
    ListUserMeResourcesQueryParams,
    {}
  >({ url: "/api/v1/resources/me", method: "get", ...variables, signal });

/**
 * Returns all the posted resources by a logged in user. In addition, if categorySlug query provided, returns only the resources posted in that category.
 */
export const useListUserMeResources = <TData = ListUserMeResourcesResponse,>(
  variables: ListUserMeResourcesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListUserMeResourcesResponse,
      ListUserMeResourcesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<
    ListUserMeResourcesResponse,
    ListUserMeResourcesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/api/v1/resources/me",
      operationId: "listUserMeResources",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListUserMeResources({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ListVotesPathParams = {
  /**
   * ID of the resource to be retrieved.
   *
   * @minLength 1
   * @example cln2u09xo0037s6wvbf6t9jfg
   */
  resourceId: string;
};

export type ListVotesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 404;
      payload: {
        /**
         * @example Resource not found
         */
        error: string;
      };
    }
>;

export type ListVotesResponse = {
  /**
   * @minimum 0
   * @example 14
   */
  upvote: number;
  /**
   * @minimum 0
   * @example 2
   */
  downvote: number;
  /**
   * @example 12
   */
  total: number;
  /**
   * @minimum -1
   * @maximum 1
   */
  userVote: number;
};

export type ListVotesVariables = {
  pathParams: ListVotesPathParams;
} & OpenapiContext["fetcherOptions"];

/**
 * Retrieve a detailed vote count for a specified resource, including the number of upvotes, downvotes, and the overall vote balance.
 */
export const fetchListVotes = (
  variables: ListVotesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListVotesResponse,
    ListVotesError,
    undefined,
    {},
    {},
    ListVotesPathParams
  >({ url: "/api/v1/vote/{resourceId}", method: "get", ...variables, signal });

/**
 * Retrieve a detailed vote count for a specified resource, including the number of upvotes, downvotes, and the overall vote balance.
 */
export const useListVotes = <TData = ListVotesResponse,>(
  variables: ListVotesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ListVotesResponse, ListVotesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<ListVotesResponse, ListVotesError, TData>({
    queryKey: queryKeyFn({
      path: "/api/v1/vote/{resourceId}",
      operationId: "listVotes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListVotes({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ListResourceTypesError = Fetcher.ErrorWrapper<undefined>;

export type ListResourceTypesResponse = ("BLOG" | "VIDEO" | "TUTORIAL")[];

export type ListResourceTypesVariables = OpenapiContext["fetcherOptions"];

/**
 * Returns an array of all the resource types
 */
export const fetchListResourceTypes = (
  variables: ListResourceTypesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListResourceTypesResponse,
    ListResourceTypesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/types", method: "get", ...variables, signal });

/**
 * Returns an array of all the resource types
 */
export const useListResourceTypes = <TData = ListResourceTypesResponse,>(
  variables: ListResourceTypesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListResourceTypesResponse,
      ListResourceTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<
    ListResourceTypesResponse,
    ListResourceTypesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/api/v1/types",
      operationId: "listResourceTypes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListResourceTypes({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ListUsersError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 403;
      payload: Schemas.ForbiddenError & void;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
>;

export type ListUsersResponse = {
  id: string;
  /**
   * @format email
   * @example user@example.cat
   */
  email: string;
  dni: string;
  name?: string;
  /**
   * @minLength 1
   */
  itineraryId: string;
  status: "ACTIVE" | "INACTIVE";
  role: "ADMIN" | "MENTOR" | "REGISTERED";
  /**
   * @format date-time
   */
  createdAt: string;
  /**
   * @format date-time
   */
  updatedAt: string;
}[];

export type ListUsersVariables = OpenapiContext["fetcherOptions"];

/**
 * Returns information of all users. User must be ADMIN and logged in.
 */
export const fetchListUsers = (
  variables: ListUsersVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<ListUsersResponse, ListUsersError, undefined, {}, {}, {}>({
    url: "/api/v1/users",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Returns information of all users. User must be ADMIN and logged in.
 */
export const useListUsers = <TData = ListUsersResponse,>(
  variables: ListUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ListUsersResponse, ListUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<ListUsersResponse, ListUsersError, TData>({
    queryKey: queryKeyFn({
      path: "/api/v1/users",
      operationId: "listUsers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListUsers({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PatchUsersByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationError;
    }
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 403;
      payload: Schemas.ForbiddenError & void;
    }
  | {
      status: 500;
      payload: {
        /**
         * @example Database error
         */
        message: string;
      };
    }
  | {
      status: 502;
      payload: Schemas.UpstreamServiceFail;
    }
>;

export type PatchUsersByIdRequestBody = {
  id: string;
  /**
   * @format email
   * @example user@example.cat
   */
  email?: string;
  dni?: string;
  /**
   * @minLength 8
   */
  password?: string;
  name?: string;
  /**
   * @minLength 1
   */
  itineraryId?: string;
  status?: "ACTIVE" | "INACTIVE";
  role?: "ADMIN" | "MENTOR" | "REGISTERED";
  specializationId?: string;
};

export type PatchUsersByIdVariables = {
  body: PatchUsersByIdRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Allows a logged in ADMIN user to modify another user.
 */
export const fetchPatchUsersById = (
  variables: PatchUsersByIdVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PatchUsersByIdError,
    PatchUsersByIdRequestBody,
    {},
    {},
    {}
  >({ url: "/api/v1/users", method: "patch", ...variables, signal });

/**
 * Allows a logged in ADMIN user to modify another user.
 */
export const usePatchUsersById = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchUsersByIdError,
      PatchUsersByIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PatchUsersByIdError,
    PatchUsersByIdVariables
  >({
    mutationFn: (variables: PatchUsersByIdVariables) =>
      fetchPatchUsersById({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PutFavoritesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ValidationError | Schemas.InputError;
    }
  | {
      status: 401;
      payload: Schemas.InvalidTokenError | Schemas.MissingTokenError;
    }
  | {
      status: 404;
      payload: Schemas.MissingUserError;
    }
>;

export type PutFavoritesRequestBody = {
  id: string;
};

export type PutFavoritesVariables = {
  body: PutFavoritesRequestBody;
} & OpenapiContext["fetcherOptions"];

/**
 * Allows a logged in users to add/remove favorite resources.
 */
export const fetchPutFavorites = (
  variables: PutFavoritesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    undefined,
    PutFavoritesError,
    PutFavoritesRequestBody,
    {},
    {},
    {}
  >({ url: "/api/v1/favorites", method: "put", ...variables, signal });

/**
 * Allows a logged in users to add/remove favorite resources.
 */
export const usePutFavorites = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PutFavoritesError,
      PutFavoritesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useOpenapiContext();
  return reactQuery.useMutation<
    undefined,
    PutFavoritesError,
    PutFavoritesVariables
  >({
    mutationFn: (variables: PutFavoritesVariables) =>
      fetchPutFavorites({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ListItinerariesError = Fetcher.ErrorWrapper<{
  status: 503;
  payload: Schemas.ServiceUnavailableError & void;
}>;

export type ListItinerariesResponse = {
  id: string;
  /**
   * @example Frontend Angular
   */
  name: string;
  /**
   * @example frontend-angular
   */
  slug: string;
}[];

export type ListItinerariesVariables = OpenapiContext["fetcherOptions"];

/**
 * Fetches all available itineraries
 */
export const fetchListItineraries = (
  variables: ListItinerariesVariables,
  signal?: AbortSignal,
) =>
  openapiFetch<
    ListItinerariesResponse,
    ListItinerariesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/itinerary", method: "get", ...variables, signal });

/**
 * Fetches all available itineraries
 */
export const useListItineraries = <TData = ListItinerariesResponse,>(
  variables: ListItinerariesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListItinerariesResponse,
      ListItinerariesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useOpenapiContext(options);
  return reactQuery.useQuery<
    ListItinerariesResponse,
    ListItinerariesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/api/v1/itinerary",
      operationId: "listItineraries",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListItineraries({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/v1/auth/me";
      operationId: "getMe";
      variables: GetMeVariables;
    }
  | {
      path: "/api/v1/auth/logout";
      operationId: "getLogout";
      variables: GetLogoutVariables;
    }
  | {
      path: "/api/v1/categories";
      operationId: "listCategories";
      variables: ListCategoriesVariables;
    }
  | {
      path: "/api/v1/topics";
      operationId: "listTopics";
      variables: ListTopicsVariables;
    }
  | {
      path: "/api/v1/resources/favorites/{categorySlug}";
      operationId: "listFavoritesResources";
      variables: ListFavoritesResourcesVariables;
    }
  | {
      path: "/api/v1/resources";
      operationId: "listResources";
      variables: ListResourcesVariables;
    }
  | {
      path: "/api/v1/resources/{resourceId}";
      operationId: "getResourcesById";
      variables: GetResourcesByIdVariables;
    }
  | {
      path: "/api/v1/resources/me";
      operationId: "listUserMeResources";
      variables: ListUserMeResourcesVariables;
    }
  | {
      path: "/api/v1/vote/{resourceId}";
      operationId: "listVotes";
      variables: ListVotesVariables;
    }
  | {
      path: "/api/v1/types";
      operationId: "listResourceTypes";
      variables: ListResourceTypesVariables;
    }
  | {
      path: "/api/v1/users";
      operationId: "listUsers";
      variables: ListUsersVariables;
    }
  | {
      path: "/api/v1/itinerary";
      operationId: "listItineraries";
      variables: ListItinerariesVariables;
    };
